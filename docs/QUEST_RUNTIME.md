# Quest Runtime Architecture

This document describes the quest runtime architecture used in `quest-app-template`, including the definition/state split, execution flow, and current implementation status.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Execution Flow](#execution-flow)
- [Implementation Status](#implementation-status)
- [Recent Changes](#recent-changes)

---

## Overview

The quest runtime uses a **compiled definition + authoritative state** architecture:

- **Quest Definition (immutable)**: Compiled adjacency graph (`compiled.json`) stored in S3
- **Runtime State (mutable, authoritative)**: Per-session/per-player state stored in DynamoDB with optimistic locking

This replaces the legacy approach of client-managed progress stored in localStorage with numeric object ordering.

### Deployment Architecture

**Production (AWS)**:
- **Backend**: Lambda + API Gateway (`https://au7pl19cc7.execute-api.us-east-2.amazonaws.com/dev`)
- **State Storage**: DynamoDB table `quest-runtime-sessions-dev` with optimistic locking
- **Quest Definitions**: S3 bucket `quest-platform-quests-dev-us-east-2`
- **Real-time**: WebSocket API for multiplayer delta broadcasting

**Frontend (Cloudflare Pages)**:
- Next.js app with `@cloudflare/next-on-pages` adapter
- Edge runtime proxy to AWS Lambda backend
- All `/api/runtime/*` routes proxy to Lambda via `awsRuntimeProxy.ts`

---

## Architecture

### Quest Definition (Immutable)

The compiled definition is validated by `docs/schemas/compiled.quest.schema.json` and includes:

#### Graph Structure
- **Object graph adjacency**: `objects[objectId].outObjectIds[]`
- **Per-object timeline graph adjacency**:
  - Linear nodes: `outNodeIds[]`
  - Branching nodes (puzzle/action): `successOutNodeIds[]` / `failureOutNodeIds[]`

#### Default Nodes (auto-generated by compiler)
- `tl_<objectId>__start` (`type=state`, `stateKind=start`)
- `tl_<objectId>__end` (`type=state`, `stateKind=end`)

#### Node Types
- **State nodes**: `__start`, `__end` (auto-advance)
- **Media nodes**: `audio`, `video`, `text`, `effect`
- **Interactive nodes**: `puzzle`, `action`

#### Policies & Gates
- Sliding window object visibility
- Player/object/session-scoped gates
- Consensus gates (`all_players_success` with `requireSameAttempt`)

#### Timeline Node IDs
Timeline nodes for `quest.json` `mediaTimeline` items are derived deterministically:
```typescript
makeTimelineItemNodeId(objectId, itemKey)
// Example: tl_3af91ac6-3000-404a-941f-8d03085a51eb:6e93384f-e90d-4d3b-bfc5-968846569ca1
```

#### Compilation
- **Source**: `quest.json` in project root
- **Compiler**: `src/runtime-core/compileQuest.ts`
- **Script**: `scripts/compile-compiled-quest.ts`
- **Command**: `npm run compile:compiled`
- **Output** (local dev): `public/compiled/<questId>@<questVersion>.json`

### Runtime State (Mutable, Authoritative)

Authoritative runtime state is held per **session** in DynamoDB:

#### Session State
```typescript
{
  sessionId: string;
  questId: string;
  questVersion: string;
  status: 'active' | 'completed';
  version: number; // Optimistic locking

  players: {
    [playerId: string]: {
      status: 'active' | 'left';
      currentObjectId: string | null;
      score: number;
      joinedAt: string;
      lastSeenAt: string;
    }
  };

  objects: {
    [objectId: string]: {
      arrivedAt: string | null;
      completedAt: string | null;
    }
  };

  nodes: {
    [nodeId: string]: {
      status: 'locked' | 'unlocked' | 'in_progress' | 'completed';
      outcome: 'success' | 'fail' | null;
      completedAt: string | null;
    }
  };

  processedEvents: Set<string>; // Idempotency
}
```

#### Implementation

**AWS Backend** (`quest-platform/backend/src/tools/quest-runtime-api/`):
- **runtime_engine.py** (737 lines): Complete Python port with 100% behavioral parity
- **dynamodb_store.py** (230 lines): Optimistic locking with conditional writes
- **lambda_handler.py** (920 lines): All HTTP routes + S3 quest loading + retry logic
- **websocket_handler.py** (155 lines): WebSocket lifecycle + delta broadcasting
- **action_verifier.py** (219 lines): Image matching + knock pattern verification

**Frontend Proxy** (`quest-app-template/src/runtime-core/awsRuntimeProxy.ts`):
- All `/api/runtime/*` routes proxy to Lambda
- Environment variable: `NEXT_PUBLIC_RUNTIME_API_URL`

### Runtime API

#### Authoritative Endpoints (AWS Lambda)

```
POST /runtime/session/start      - Start or join session (optional `reset: true` to force new session)
POST /runtime/session/join       - Join existing session
POST /runtime/object/arrive      - Record object arrival
POST /runtime/node/complete      - Complete timeline node
POST /runtime/puzzle/submit      - Submit puzzle result
POST /runtime/action/start       - Start action (get attempt token)
POST /runtime/action/submit      - Submit action result
GET  /runtime/session/{id}       - Get session snapshot
GET  /runtime/compiled            - Get compiled quest definition
```

#### Idempotency (Required)

All client events must include:
- `eventId` (unique per client emission, e.g., `evt_abc123_1234567890`)
- `dedupeKey` (stable per semantic action, e.g., `nodeComplete:player123:nodeABC`)

The store rejects duplicates and the engine remains deterministic.

---

### Action Nodes Specification

Action nodes require specific evidence verification logic implemented in `action_verifier.py`.

#### Image Match Action (`image_match`)
Validates an uploaded image against a target reference image using the `image-matcher-rust` Lambda service.

**Client-Side Processing:**
- Images are automatically resized locally before upload to fit within a **1280x1280** bounding box (maintaining aspect ratio).
- Images are compressed to JPEG with **0.8 quality** to ensure payload size (< 5MB) is compatible with Lambda constraints.

**Quest Definition Paramaters:**
- `targetImageKey`: Key of the reference image in S3.
- `maxScore`: (Optional) Similarity threshold (0.0 - 2.0). Default `0.6`. Lower is better.
- `maxDistanceMeters`: (Optional) Max allowed distance from target. Default `10.0`.
- `targetLatitude` / `targetLongitude`: (Optional) required for distance check.

**Submission Evidence:**
```json
{
  "queryImagePath": "clients/.../image.jpg",
  "playerLatitude": 45.123,   // Optional
  "playerLongitude": 12.123   // Optional
}
```

**Verification Logic:**
1. Call `image-matcher-rust` with `queryImagePath`
2. Validate **Score**: `topMatch.score < maxScore`
3. Validate **Target**: `topMatch.id` contains `targetImageKey`
4. Validate **Distance** (if coords provided): `distance(player, target) < maxDistanceMeters`
5. Outcome is `success` only if **ALL** checks pass.

#### Knock Action (`knock`)
Validates a rhythmic pattern of taps/knocks.

**Quest Definition Parameters:**
- `requiredKnocks`: Number of knocks required. Default `3`.
- `maxIntervalMs`: Max duration of the full pattern. Default `2000`ms.
- `expectedPattern`: (Optional) Array of relative intervals (e.g., `[100, 100]` for constant tempo).
- `patternTolerance`: (Optional) Matching tolerance (0.0 - 1.0). Default `0.3` (30%).

**Submission Evidence:**
```json
{
  "knockPattern": [1704350000100, 1704350000500, 1704350001000] // Timestamps
}
```

**Verification Logic:**
1. Sort timestamps
2. Find any contiguous window of `requiredKnocks` length
3. Validate **Duration**: `windowDuration <= maxIntervalMs`
4. Validate **Pattern** (if expectedPattern set): Compare validity of relative intervals against `expectedPattern` using `patternTolerance`.
5. Outcome is `success` if any valid window is found.

---

## Execution Flow

### 1. Session Initialization

**Trigger**: Player app loads (`page.tsx` ‚Üí `useQuestSession`)

```typescript
// src/hooks/useQuestRuntime.ts
const { snapshot, startOrJoin } = useQuestRuntime({
  questId: 'quest-74b36181',
  questVersion: 'v1',
  playerId: 'player123',
  teamCode: null,
  autoStart: true
});

await startOrJoin(); // Calls POST /api/runtime/session/start
```

**Response**:
```json
{
  "success": true,
  "sessionId": "player123",
  "snapshot": {
    "players": {
      "player123": {
        "currentObjectId": "kitchen-001", // First object
        "score": 0
      }
    },
    "nodes": {}, // Empty until arrival
    "objects": {}
  },
  "deltas": [
    { "type": "SESSION_STARTED", "playerId": "player123" }
  ]
}
```

**Frontend State**:
- `QuestMap` shows target object (often with pulsating effect)
- `currentObjectId` indicates where player should go

### 2. Object Arrival (Progression Trigger)

**Critical Step**: This unlocks timeline content (audio, puzzles, etc.)

#### Geolocation Detection

```typescript
// src/components/QuestMap.tsx
useProximityTracker({
  objects: visibleObjects,
  onEnterZone: (obj) => {
    handleObjectArrival(obj);
  }
});
```

**Trigger Condition**: `distance <= triggerRadius` (default 20m)

#### Execution Chain

1. `useProximityTracker` ‚Üí `handleEnterZone` (QuestMap.tsx)
2. `handleEnterZone` ‚Üí `handleObjectArrival` (useArrivalSimulation.ts)
3. `handleObjectArrival` ‚Üí `runtime.arriveAtObject(obj.id)`
4. API call: `POST /api/runtime/object/arrive`

**Backend Processing**:
```python
# AWS Lambda: runtime_engine.py
def handle_object_arrive(definition, session, event):
    # 1. Mark object as arrived
    obj_state.arrived_at = now_iso()

    # 2. Unlock start node
    start_node_id = f"tl_{object_id}__start"
    unlock_node(session, player_id, start_node_id, deltas)

    # 3. Auto-advance through state nodes
    auto_advance_state_nodes(definition, session, [player_id], [start_node_id], deltas)

    # 4. Unlock outgoing nodes from __start
    for out_id in start_node.out_node_ids:
        unlock_node(session, player_id, out_id, deltas)
```

**Response**:
```json
{
  "success": true,
  "snapshot": {
    "objects": {
      "kitchen-001": { "arrivedAt": "2026-01-01T09:00:00Z" }
    },
    "nodes": {
      "tl_kitchen-001__start": { "status": "completed" },
      "tl_kitchen-001:audio-intro": { "status": "unlocked" } // ‚Üê Timeline starts
    }
  },
  "deltas": [
    { "type": "OBJECT_ARRIVED", "objectId": "kitchen-001" },
    { "type": "NODE_UNLOCKED", "nodeId": "tl_kitchen-001:audio-intro" }
  ]
}
```

### 3. Timeline Execution

**Component**: `src/components/object-timeline/useObjectTimeline.ts`

#### Timeline Runner Flow

```typescript
const runObjectTimeline = async (obj: QuestObject) => {
  // 1. Compute initial progress from runtime snapshot
  let progress = computeRuntimeTimelineProgress(obj.id, timeline.items, false);

  // 2. Sequential execution
  for (let idx = progress.nextIndex; idx < timeline.items.length; idx++) {
    const item = timeline.items[idx];

    // 3. Execute item (audio, video, text, effect, puzzle)
    if (item.type === 'audio') {
      await playAudioBlocking({ url, objectName, objectId });
    }

    // 4. Complete node in runtime
    await completeRuntimeNode(obj.id, item.key);
    // ‚Üí Calls POST /api/runtime/node/complete

    // 5. Re-compute progress with updated snapshot
    // This detects newly unlocked nodes from backend
    progress = computeRuntimeTimelineProgress(obj.id, timeline.items, false, idx + 1);

    // 6. Continue to next item
  }
};
```

**Key Feature**: After completing each node, the runner re-computes timeline progress using the updated runtime snapshot. This ensures that if the backend unlocks additional nodes (based on the compiled quest graph), the frontend automatically continues processing them.

#### Node Completion Backend Logic

```python
# runtime_engine.py
def handle_node_complete(definition, session, event):
    node_id = event['nodeId']
    player_id = event['playerId']

    # 1. Mark node as completed
    complete_node(session, player_id, node_id, deltas)

    # 2. Unlock outgoing nodes based on adjacency
    node = definition['timelineNodes'][node_id]
    for out_id in node.get('outNodeIds', []):
        unlock_node(session, player_id, out_id, deltas)

    # 3. Auto-advance through any state nodes
    auto_advance_state_nodes(definition, session, [player_id], node['outNodeIds'], deltas)
```

### 4. Puzzle Submission

```typescript
// Puzzle page calls:
await runtime.submitPuzzleSuccess({
  puzzleId: 'word-search-1',
  objectId: 'kitchen-001',
  points: 100
});
```

**Backend**: Puzzle nodes use branching adjacency:
- `successOutNodeIds[]` - unlocked on success
- `failureOutNodeIds[]` - unlocked on failure

### 5. Real-time Sync (WebSocket)

**Primary Truth**: HTTP response immediately updates local client state

**WebSocket Purpose**: Sync updates from other teammates

```typescript
// src/lib/useTeamWebSocket.ts
useEffect(() => {
  socket.on('quest_runtime_deltas', (message) => {
    // Dispatch window event ‚Üí triggers useQuestRuntime refresh
    window.dispatchEvent(new CustomEvent('quest_runtime_deltas'));
  });
}, []);
```

**WebSocket Flow**:
1. Teammate A completes a puzzle
2. Lambda broadcasts `quest_runtime_deltas` to all connected WebSocket clients in session
3. Teammate B receives delta message
4. `useQuestRuntime` auto-refreshes via `GET /runtime/session/{sessionId}`

---

## Implementation Status

### ‚úÖ Completed Features

#### Core Runtime Engine
- [x] Compiled quest definition schema + TypeScript types
- [x] Quest compiler (`quest.json` ‚Üí `compiled.json`)
- [x] Deterministic state transition engine (Python + TypeScript ports)
- [x] Idempotency with `eventId` + `dedupeKey`
- [x] Object visibility (sliding window policies)
- [x] Auto-advancing state nodes (`__start` / `__end`)

#### AWS Backend Deployment
- [x] Python runtime engine (100% behavioral parity, 737 lines)
- [x] DynamoDB store with optimistic locking (230 lines)
- [x] Lambda handler with all HTTP routes (920 lines)
- [x] S3 quest definition loading
- [x] WebSocket delta broadcasting (155 lines)
- [x] Action verification (image matching + knock pattern, 219 lines)
- [x] CDK infrastructure deployment via GitHub Actions
- [x] API Gateway endpoint: `https://au7pl19cc7.execute-api.us-east-2.amazonaws.com/dev`

#### Frontend Integration
- [x] `useQuestRuntime` hook (replaces `useQuestProgress`)
- [x] QuestMap migration to runtime-driven visibility
- [x] Timeline runner reports node completions to runtime
- [x] WebSocket client integration (listens for `quest_runtime_deltas`)
- [x] AWS runtime proxy (`awsRuntimeProxy.ts`)
- [x] All 9 `/api/runtime/*` routes proxy to Lambda

#### Action Nodes
- [x] `POST /runtime/action/start` - generates attempt tokens
- [x] `POST /runtime/action/submit` - verifies evidence + applies outcome
- [x] Session-scope consensus gates (`all_players_success` with `requireSameAttempt`)
- [x] Image matching integration (AWS Lambda `image-matcher-rust`)
- [x] Knock pattern matching with normalized intervals

#### Timeline Navigation Fix (2026-01-01)
- [x] Timeline runner now detects newly unlocked nodes after each completion
- [x] Added 50ms state update delay in `completeRuntimeNode`
- [x] Re-computes progress using updated runtime snapshot after each node
- [x] Fixes bug where timeline didn't continue after puzzle completion

### üöß Pending Work

#### Infrastructure
- [ ] Environment variable configuration in Cloudflare Pages (`NEXT_PUBLIC_RUNTIME_API_URL`)
- [ ] Upload latest compiled quest to S3 (ensure deployed app matches S3 definition)
- [ ] End-to-end integration testing (Next.js client ‚Üî AWS backend)

#### Runtime Features
- [ ] Additional gate types beyond `all_players_success`
- [ ] Remove legacy compatibility endpoints after full migration
  - `POST /api/quest/complete-object` (deprecated - objects auto-complete at `__end` node)
  - `GET /api/quest/session/{sessionId}` (legacy projection, should use runtime endpoint)

#### Documentation
- [ ] API endpoint documentation with request/response examples
- [ ] Compiled quest schema documentation with visual examples
- [ ] Debugging guide for common issues

### Known Limitations

1. **Object Completion**: Objects complete automatically when timeline reaches `__end` node via `autoAdvanceStateNodes`. The manual `POST /api/quest/complete-object` endpoint is deprecated and only exists for backward compatibility.

2. **Quest Version**: Currently hard-coded to `v1` in many places. Multi-version support exists in the schema but isn't fully wired through the UI.

3. **Compiled Quest Sync**: The compiled quest in the deployed app (`public/compiled/`) may differ from the S3 version. Always ensure S3 has the latest compiled definition.

---

## Recent Changes

### 2026-01-01: Timeline Resume After Puzzle Fix (Part 3)

**Problem**: After completing a puzzle and returning to the map, the timeline would not resume and continue to the next items (video ‚Üí audio ‚Üí __end).

**Root Cause Analysis**:

This issue had **three separate root causes** that needed to be fixed:

#### Issue 1: Stale Client Snapshot Cache (commit `dfc5ddd`)

**Problem**: `PuzzleClient.tsx` was calling the puzzle submit API directly via `fetch()`, which updated the server state in DynamoDB but **discarded the server response** containing the updated snapshot. This caused the local snapshot cache to become stale.

**Flow**:
```
PuzzleClient ‚Üí fetch('/api/runtime/puzzle/submit') ‚Üí Server updates DynamoDB ‚úÖ
                                                    ‚Üí Response with snapshot ‚ùå IGNORED
QuestMap ‚Üí Uses stale snapshot ‚Üí Timeline can't detect completed puzzle ‚ùå
```

**Solution**: Modified `PuzzleClient.tsx` to use `runtime.submitPuzzleSuccess()` from the Quest context instead of direct fetch calls.

```typescript
// Before (broken):
await fetch('/api/runtime/puzzle/submit', { ... });
const result = await response.json();
// Response snapshot discarded!

// After (fixed):
await runtime.submitPuzzleSuccess({
  puzzleId: resolvedPuzzleId,
  objectId: objectId || undefined,
  points
});
// Snapshot automatically updated in cache
```

**Why this maintains server authority**: The local snapshot is just a **cache of the authoritative DynamoDB state**. `runtime.submitPuzzleSuccess()` calls the server API and updates the cache with the server's response, keeping them synchronized.

#### Issue 2: Timeline Run Guard Blocking Resumption (commit `88572f2`)

**Problem**: The timeline runner's `timelineRunRef` was preventing resumption because the "continue-if-already-playing" guard thought the timeline was still running.

**Flow**:
1. Player navigates to puzzle page ‚Üí timeline breaks with `timelineRunRef = { objectId, version, cancel: false }`
2. Line 647 clears it after timeline loop finishes
3. **BUT** when navigating to puzzle page, the loop breaks early (line 642) before reaching line 647
4. Player completes puzzle and navigates back ‚Üí QuestMap calls `runObjectTimeline`
5. Guard at lines 394-402 checks if timeline is "already playing" for same object/version
6. Since `timelineRunRef` is still set, it returns early thinking timeline is running
7. Timeline never resumes

**Solution**: Clear `timelineRunRef.current` when `completedPuzzles` size increases, signaling a puzzle was completed.

```typescript
// Added in useObjectTimeline.ts
useEffect(() => {
  if (questRuntime.completedPuzzles.size > prevCompletedPuzzlesSizeRef.current) {
    console.log('[useObjectTimeline] Puzzle completed, clearing timeline run ref to allow resumption');
    timelineRunRef.current = null;
    prevCompletedPuzzlesSizeRef.current = questRuntime.completedPuzzles.size;
  }
}, [questRuntime.completedPuzzles]);
```

#### Issue 3: Excessive useEffect Re-runs (commit `aad9895`)

**Problem**: The timeline resume useEffect in QuestMap was triggering hundreds of times during audio playback with streaming transcription, causing performance degradation.

**Root Cause**:
- `isCurrentObjectCompleted` was being recreated on every render
- `runObjectTimeline` was in the dependency array and was being recreated when audio functions changed
- This caused the useEffect to re-run on every transcription word update

**Solution**:
1. Memoized `isCurrentObjectCompleted` to prevent recreation
2. Used a stable ref pattern for `runObjectTimeline` instead of including it in dependencies
3. Replaced `runObjectTimeline` dependency with `runtime.definition`

```typescript
// Memoize completion status
const isCurrentObjectCompleted = useMemo(
  () => !!currentObjectId && runtime.completedObjects.has(currentObjectId),
  [currentObjectId, runtime.completedObjects]
);

// Stable ref for runObjectTimeline
const runObjectTimelineRef = useRef(runObjectTimeline);
useEffect(() => {
  runObjectTimelineRef.current = runObjectTimeline;
}, [runObjectTimeline]);

// useEffect now only triggers on meaningful state changes
useEffect(() => {
  // ... resume logic
  void runObjectTimelineRef.current(currentObj);
}, [currentSessionId, currentObjectId, isCurrentObjectCompleted, objectsById, runtime.definition]);
```

**Files Changed**:
- `src/app/puzzle/[id]/PuzzleClient.tsx` (snapshot cache synchronization)
- `src/components/object-timeline/useObjectTimeline.ts` (timeline ref clearing)
- `src/components/QuestMap.tsx` (useEffect optimization)

**Commits**:
- `dfc5ddd` - Fix puzzle completion timeline resume issue
- `88572f2` - Clear timeline run ref when puzzle completes to allow resumption
- `aad9895` - Optimize timeline resume useEffect to prevent excessive re-runs

**Impact**: Timeline now correctly:
1. Updates local snapshot cache when puzzles complete (maintains server state sync)
2. Clears timeline run guard to allow resumption after navigation
3. Only triggers resume logic when meaningful state changes occur
4. Continues through all remaining timeline items (video ‚Üí audio ‚Üí __end)
5. Marks object as complete when reaching `__end` node

### 2026-01-01: RepeatPolicy Removal

**Problem**: Complex `repeatPolicy` logic was causing timeline traversal issues where the timeline would incorrectly calculate `nextIndex: 0` after puzzle completion instead of continuing from the correct position.

**Root Cause**: The timeline system had a `repeatPolicy` attribute with three values:
- `once_per_object`: Item plays once per object, skipped on revisit
- `on_each_arrival`: Item plays on every arrival
- `always`: Item always plays (only used for state nodes)

This created confusing logic in `computeRuntimeTimelineProgress` where the function treated items differently based on their repeat policy. Items with `repeatPolicy: "on_each_arrival"` (typically non-blocking audio) would not be skipped even if completed, causing the timeline to find index 0 as the "next" item instead of the actual next uncompleted item.

**Solution**: Removed the entire `repeatPolicy` concept from the quest system.

**New Behavior**: All timeline items are now treated uniformly:
- If a node is marked as `status: 'completed'` in the runtime snapshot, it gets skipped
- The timeline continues to the next uncompleted item
- Revisiting an object replays all items (no distinction between "once" vs "on each arrival")

**Implementation Details**:

1. **Type Definitions Cleanup** ([quest.ts:2](src/types/quest.ts#L2), [compiledQuest.ts:8](src/runtime-core/compiledQuest.ts#L8))
   - Removed `MediaTimelineRepeatPolicy` type
   - Removed `repeatPolicy` field from `MediaTimelineItemBase`
   - Removed `RepeatPolicy` type
   - Removed `repeatPolicy` field from `TimelineNodeCommon`
   - Removed `defaultRepeatPolicy` from `TimelinePolicy`

2. **Quest Compilation** ([compileQuest.ts:150](src/runtime-core/compileQuest.ts#L150), [quest_compiler.py:1](../../quest-platform/backend/src/tools/deployment-manager/quest_compiler.py#L1))
   - Removed `toRepeatPolicy()` function (TypeScript)
   - Removed `to_repeat_policy()` function (Python)
   - Removed repeatPolicy assignment in timeline node creation
   - Removed repeatPolicy normalization in `normalizeMediaTimeline()`

3. **Timeline Traversal** ([useObjectTimeline.ts:274](src/components/object-timeline/useObjectTimeline.ts#L274))
   - Simplified `computeRuntimeTimelineProgress` to uniformly skip all completed items
   - Removed conditional logic checking `item.repeatPolicy === 'once_per_object'`
   - Now builds `completedKeys` map from ALL completed nodes in snapshot
   - Skips ALL items where `completedKeys[item.key]` is true

4. **JSON Schema** ([compiled.quest.schema.json:1](docs/schemas/compiled.quest.schema.json#L1))
   - Removed `repeatPolicy` definition from `$defs`
   - Removed `repeatPolicy` requirement from `timelineNodeCommon`
   - Removed `defaultRepeatPolicy` from timeline policy

**Code Changes**:

```typescript
// Before: Complex conditional logic
const completedKeys: Record<string, true> = {};
for (const item of items) {
  if (!item.enabled) continue;
  if (item.repeatPolicy !== 'once_per_object') continue;  // ‚ùå Conditional
  const nodeId = makeTimelineItemNodeId(objectId, item.key);
  const node = snapshotRef.current?.nodes?.[nodeId];
  if (node?.status === 'completed') {
    completedKeys[item.key] = true;
  }
}

// After: Uniform treatment
const completedKeys: Record<string, true> = {};
for (const item of items) {
  if (!item.enabled) continue;
  const nodeId = makeTimelineItemNodeId(objectId, item.key);
  const node = snapshotRef.current?.nodes?.[nodeId];
  if (node?.status === 'completed') {  // ‚úÖ No conditionals
    completedKeys[item.key] = true;
  }
}
```

**Files Changed**:
- TypeScript (quest-app-template):
  - `src/types/quest.ts` - Type definitions
  - `src/runtime-core/compiledQuest.ts` - Compiled quest types
  - `src/runtime-core/compileQuest.ts` - Quest compiler
  - `src/lib/mediaTimeline.ts` - Timeline normalization
  - `src/components/object-timeline/useObjectTimeline.ts` - Timeline traversal logic
  - `docs/schemas/compiled.quest.schema.json` - JSON schema

- Python (quest-platform):
  - `backend/src/tools/deployment-manager/quest_compiler.py` - Lambda quest compiler

**Commits**:
- [27734d0](https://github.com/user/quest-app-template/commit/27734d0) - Remove repeatPolicy from TypeScript codebase
- [b5b747e](https://github.com/user/quest-platform/commit/b5b747e) - Remove repeatPolicy from Python compiler

**Deployment**:
1. Pushed to GitHub ‚Üí GitHub Actions deployed Lambda with updated Python compiler
2. Lambda recompiled quest without repeatPolicy fields
3. Quest uploaded to S3
4. Deployed app loads compiled quest from S3

**Impact**: Timeline traversal is now simpler and more predictable:
- No special cases for different item types
- All completed items are skipped uniformly
- Timeline correctly resumes after puzzle completion
- Reduced cognitive complexity in timeline progression logic

### 2026-01-02: Object Completion Scoring Fix

**Problem**: When players completed all timeline items for an object, the "For" points (voting metric) were not being added to their score. The object appeared complete in the UI, but no points were awarded.

**Root Cause**: The timeline runner processed all items correctly (audio ‚Üí streaming text ‚Üí puzzle ‚Üí video ‚Üí final audio), but after the last item completed, the timeline loop exited **without completing the `__end` node**.

According to the Runtime API scoring logic ([runtime_engine.py:429-464](https://github.com/user/quest-platform/blob/dev/backend/src/tools/quest-runtime-api/runtime_engine.py#L429-L464)), points are only awarded when the `__end` node is reached via auto-advance:

```python
# Award points for completing the object
object_points = definition.get('objects', {}).get(object_id, {}).get('points', 0)
if object_points > 0:
    # Count active players to divide points equally
    active_players = [
        pid for pid, player in session.players.items()
        if player.status == PlayerStatus.ACTIVE
    ]
    num_active_players = len(active_players)

    if num_active_players > 0:
        # Divide points equally among active players
        points_per_player = object_points // num_active_players

        # Award points to each active player
        for pid in active_players:
            session.players[pid].score += points_per_player
            deltas.append(ScoreUpdatedDelta(
                player_id=pid,
                score=session.players[pid].score
            ))
```

Since the `__end` node was never completed, the auto-advance logic never triggered, and no points were awarded.

**Solution**: Added explicit `__end` node completion in the timeline runner after all items are processed.

**Implementation** ([useObjectTimeline.ts:695-705](src/components/object-timeline/useObjectTimeline.ts#L695-L705)):

```typescript
// If we completed all timeline items, complete the __end node to trigger object completion and point distribution
if (idx >= timeline.items.length) {
  console.log('[useObjectTimeline] All timeline items completed, completing __end node');
  const endNodeId = `tl_${sanitizeIdPart(obj.id)}__end`;
  try {
    await questRuntime.completeNode(endNodeId);
    console.log('[useObjectTimeline] __end node completed successfully');
  } catch (err) {
    console.warn('[useObjectTimeline] Failed to complete __end node:', { objectId: obj.id, endNodeId, err });
  }
}
```

**Files Changed**:
- `src/components/object-timeline/useObjectTimeline.ts`
  - Added `__end` node completion after timeline loop completes
  - Imported `sanitizeIdPart` to construct end node ID

**Commit**: [d193f29](https://github.com/densmyslov/quest-app-template/commit/d193f29)

**Server-Side Flow**:
1. Frontend completes `__end` node ‚Üí `POST /api/runtime/node/complete`
2. Lambda `auto_advance_state_nodes` detects end node (stateKind='end')
3. Marks object as completed: `obj_state.completed_at = now_iso()`
4. Retrieves object points from compiled definition
5. Counts active players in session
6. Divides points equally: `points_per_player = object_points // num_active_players`
7. Updates each player's score
8. Emits `ObjectCompletedDelta` and `ScoreUpdatedDelta` events
9. Frontend receives updated snapshot with new scores
10. "Votes For" metric updates in GameStatusPanel

**Impact**:
- Object completion now correctly triggers point distribution
- "Votes For" metric updates immediately when objects are completed
- Players receive their earned points in real-time
- Scoring metrics board displays accurate progress
- Solo and team mode scoring both work correctly

**Debugging**:
- Check browser console for `[useObjectTimeline] __end node completed successfully`
- Check Lambda logs for `[AUTO_ADVANCE] Object {id} has {points} points configured`
- Verify object has `points` value > 0 in Quest Platform dashboard
- Check runtime snapshot: `runtime.snapshot.players[playerId].score` should increase

### Earlier Timeline Fixes (2025-12)

**Part 1: Node Completion Detection** (commit `770bb8c`)
1. Modified `computeRuntimeTimelineProgress` to accept optional `currentIndex` parameter
2. After completing each timeline node, re-compute progress using updated runtime snapshot
3. Added 50ms delay after `completeNode` to ensure React state updates with new snapshot
4. Timeline now automatically detects and continues processing newly unlocked nodes

**Part 2: Timeline Resume After Puzzle** (commit `80bbea2`)
1. Added `useEffect` in QuestMap that detects puzzle completion by watching `runtime.completedPuzzles.size`
2. When puzzle completes, resets `lastResumedObjectRef.current = null`
3. Allows timeline resume logic to trigger again after returning from puzzle page

### 2025-12: AWS Runtime Migration

**Migration**: Replaced in-memory runtime state with AWS Lambda + DynamoDB backend

**Changes**:
1. Created `quest-runtime-api` Lambda function with Python runtime engine
2. Added DynamoDB table `quest-runtime-sessions-dev` with optimistic locking
3. Created S3 bucket `quest-platform-quests-dev-us-east-2` for compiled quests
4. Added API Gateway endpoint with 9 runtime routes
5. Created `awsRuntimeProxy.ts` to proxy all frontend `/api/runtime/*` calls to Lambda
6. Updated all runtime API routes to use proxy instead of in-memory state

**CDK Stack** (commit `9f0f4ee`):
- Added DynamoDB table with GSI for playerId lookups
- Added Lambda function with S3 read permissions
- Added API Gateway routes for runtime operations
- Deployed to `us-east-2` region

**Environment Variables**:
- `NEXT_PUBLIC_RUNTIME_API_URL`: API Gateway endpoint for client-side calls
- `RUNTIME_API_URL`: API Gateway endpoint for server-side calls

### 2025-11: Initial Runtime Implementation

**Created**:
1. Compiled quest schema + validator
2. Quest compiler (TypeScript)
3. In-memory runtime store (replaced by DynamoDB)
4. Deterministic state transition engine (TypeScript, later ported to Python)
5. `useQuestRuntime` hook
6. QuestMap integration with runtime-driven visibility

---

## Debugging Tips

### Timeline Issues

**Symptom**: Audio doesn't play after arriving at object

**Check**:
1. Network tab: Look for `POST /api/runtime/object/arrive` ‚Üí should return `NODE_UNLOCKED` deltas
2. Console: `[QuestRuntime]` logs show snapshot with unlocked nodes
3. React DevTools: Check `useQuestRuntime` ‚Üí `snapshot.nodes` ‚Üí verify node status is `unlocked`
4. Timeline state: Check `timelineUi.progress.nextIndex` matches expected item

**Common Causes**:
- Compiled quest in S3 doesn't match local `public/compiled/`
- Node IDs mismatch between `quest.json` timeline items and compiled graph
- Timeline blocked by modal or puzzle state

**Symptom**: Timeline doesn't continue after puzzle completion

**Check**:
1. Verify puzzle was completed successfully: Check `runtime.completedPuzzles` includes puzzle ID
2. Check console for `[QuestMap]` logs showing timeline resume attempt
3. Verify `lastResumedObjectRef` was reset after puzzle completion
4. Check compiled quest for correct `successOutNodeIds` from puzzle node

**Debug Steps**:
```javascript
// In browser console
window.runtime.completedPuzzles // Should include puzzle ID
window.runtime.snapshot.nodes // Check video/audio nodes after puzzle have status 'unlocked'
```

**Common Causes**:
- `lastResumedObjectRef` not reset after puzzle completion (fixed in commit 80bbea2)
- Puzzle node missing `successOutNodeIds` in compiled quest
- Video/audio nodes not unlocked by backend after puzzle success
- Navigation from puzzle page interrupted timeline state

### Multiplayer Sync Issues

**Symptom**: Teammate's progress doesn't appear

**Check**:
1. WebSocket connection: Look for `[TeamWebSocket] Connected` in console
2. Delta messages: Should see `quest_runtime_deltas` events in WebSocket messages
3. Refresh trigger: Verify `useQuestRuntime` auto-refreshes after delta event

### API Proxy Issues

**Symptom**: Runtime API calls fail with 500 or CORS errors

**Check**:
1. Environment variable: Verify `NEXT_PUBLIC_RUNTIME_API_URL` is set in Cloudflare Pages
2. Lambda logs: Check CloudWatch for error details
3. CORS headers: Verify Lambda returns proper CORS headers for browser requests
4. API Gateway routes: Ensure all 9 routes exist and point to Lambda

### State Consistency Issues

**Symptom**: DynamoDB version conflicts or stale state

**Check**:
1. Lambda logs: Look for "ConditionalCheckFailed" errors (optimistic locking)
2. Retry logic: Verify Lambda retries with exponential backoff (max 5 attempts)
3. Session version: Check DynamoDB item `version` field increments correctly
4. Idempotency: Verify `eventId` + `dedupeKey` in logs to detect duplicates

---

## See Also

- `docs/schemas/compiled.quest.schema.json` - Compiled quest schema definition
- `src/runtime-core/compileQuest.ts` - Quest compiler implementation
- `src/hooks/useQuestRuntime.ts` - Frontend runtime integration
- `quest-platform/backend/src/tools/quest-runtime-api/` - AWS backend implementation
